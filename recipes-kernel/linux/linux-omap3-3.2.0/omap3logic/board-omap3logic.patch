diff --git a/arch/arm/mach-omap2/board-omap3logic.c b/arch/arm/mach-omap2/board-omap3logic.c
--- a/arch/arm/mach-omap2/board-omap3logic.c
+++ b/arch/arm/mach-omap2/board-omap3logic.c
@@ -1,49 +1,68 @@
 /*
- * linux/arch/arm/mach-omap2/board-omap3logic.c
+ * board-omap3logic.c (LogicPD Torpedo)
  *
- * Copyright (C) 2010 Li-Pro.Net
- * Stephan Linz <linz@li-pro.net>
+ * Initial code: Steve Sakoman <steve@sakoman.com>
  *
- * Copyright (C) 2010 Logic Product Development, Inc.
- * Peter Barada <peter.barada@logicpd.com>
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * Modified from Beagle, EVM, and RX51
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
-#include <linux/clk.h>
+#include <linux/init.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
-
+#include <linux/kernel.h>
+#include <linux/opp.h>
+#include <linux/platform_device.h>
+#include <linux/i2c/twl.h>
 #include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/spi/spi.h>
 
-#include <linux/i2c/twl.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
 #include <linux/mmc/host.h>
 
-#include <mach/hardware.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
 #include <asm/mach/map.h>
 
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/omap_device.h>
+#include <video/omapdss.h>
+#include <video/omap-panel-generic-dpi.h>
+#include <video/omap-panel-dvi.h>
+#include <plat/gpmc.h>
+#include <mach/hardware.h>
+#include <plat/nand.h>
+#include <plat/mcspi.h>
+#include <plat/mux.h>
+#include <plat/usb.h>
+
 #include "mux.h"
+#include "pm.h"
+#include "sdram-micron-mt46h32m32lf-6.h"
 #include "hsmmc.h"
-#include "control.h"
 #include "common-board-devices.h"
 
-#include <plat/mux.h>
-#include <plat/board.h>
-#include <plat/common.h>
-#include <plat/gpmc-smsc911x.h>
-#include <plat/gpmc.h>
-#include <plat/sdrc.h>
+
 
 #define OMAP3LOGIC_SMSC911X_CS			1
 
@@ -54,10 +73,126 @@
 #define OMAP3_TORPEDO_MMC_GPIO_CD		127
 #define OMAP3_TORPEDO_SMSC911X_GPIO_IRQ		129
 
+
+#if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+
+#include <linux/smsc911x.h>
+#include <plat/gpmc-smsc911x.h>
+
+static struct omap_smsc911x_platform_data __initdata board_smsc911x_data = {
+	.cs             = OMAP3LOGIC_SMSC911X_CS,
+	.gpio_irq       = -EINVAL,
+	.gpio_reset     = -EINVAL,
+};
+
+static void __init omap3logic_init_smsc911x(void)
+{
+	if (machine_is_omap3530_lv_som() || machine_is_dm3730_som_lv()) {
+		/* OMAP3530 LV SOM board */
+		board_smsc911x_data.gpio_irq =
+					OMAP3530_LV_SOM_SMSC911X_GPIO_IRQ;
+		omap_mux_init_signal("gpio_152", OMAP_PIN_INPUT);
+	} else if (machine_is_omap3_torpedo() || machine_is_dm3730_torpedo()) {
+		/* OMAP3 Torpedo board */
+		board_smsc911x_data.gpio_irq = OMAP3_TORPEDO_SMSC911X_GPIO_IRQ;
+		omap_mux_init_signal("gpio_129", OMAP_PIN_INPUT);
+	} else {
+		/* unsupported board */
+		printk(KERN_ERR "%s(): unknown machine type\n", __func__);
+		return;
+	}
+
+	gpmc_smsc911x_init(&board_smsc911x_data);
+}
+
+#else
+static inline void __init omap3logic_init_smsc911x(void) { return; }
+#endif
+
+static struct mtd_partition omap_nand_partitions[] = {
+	{
+		.name           = "xloader",
+		.offset         = 0,			/* Offset = 0x00000 */
+		.size           = 4 * NAND_BLOCK_SIZE,
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size           = 14 * NAND_BLOCK_SIZE,
+	},
+	{
+		.name           = "uboot environment",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x240000 */
+		.size           = 2 * NAND_BLOCK_SIZE,
+	},
+	{
+		.name           = "linux",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x280000 */
+		.size           = 32 * NAND_BLOCK_SIZE,
+	},
+	{
+		.name           = "rootfs",
+		.offset         = MTDPART_OFS_APPEND,	/* Offset = 0x680000 */
+		.size           = MTDPART_SIZ_FULL,
+	},
+};
+
+static struct omap2_hsmmc_info __initdata board_mmc_info[] = {
+	{
+		.name		= "external",
+		.mmc		= 1,
+		.caps		= MMC_CAP_4_BIT_DATA,
+		.gpio_cd	= -EINVAL,
+		.gpio_wp	= -EINVAL,
+	},
+	{
+		.name		= "wl1271",
+		.mmc		= 3,
+		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_POWER_OFF_CARD,
+		.gpio_cd	= -EINVAL,
+		.gpio_wp	= -EINVAL,
+		.nonremovable	= true,
+	},
+	{}      /* Terminator */
+};
+
 static struct regulator_consumer_supply omap3logic_vmmc1_supply[] = {
 	REGULATOR_SUPPLY("vmmc", "omap_hsmmc.0"),
 };
 
+static void __init board_mmc_init(void)
+{
+	if (machine_is_omap3530_lv_som() || machine_is_dm3730_som_lv()) {
+		/* OMAP35x/DM37x LV SOM board */
+		board_mmc_info[0].gpio_cd = OMAP3530_LV_SOM_MMC_GPIO_CD;
+		board_mmc_info[0].gpio_wp = OMAP3530_LV_SOM_MMC_GPIO_WP;
+		/* gpio_cd for MMC wired to CAM_STROBE; cam_strobe and
+		 * another pin share GPIO_126. Mux CAM_STROBE as GPIO. */
+		omap_mux_init_signal("cam_strobe.gpio_126", OMAP_MUX_MODE4 | OMAP_PIN_INPUT_PULLUP);
+	} else if (machine_is_omap3_torpedo() || machine_is_dm3730_torpedo()) {
+		/* OMAP35x/DM37x Torpedo board */
+		board_mmc_info[0].gpio_cd = OMAP3_TORPEDO_MMC_GPIO_CD;
+		omap_mux_init_signal("gpio_127", OMAP_PIN_OUTPUT);
+	} else {
+		/* unsupported board */
+		printk(KERN_ERR "%s(): unknown machine type\n", __func__);
+		return;
+	}
+
+	omap2_hsmmc_init(board_mmc_info);
+}
+
+static struct twl4030_gpio_platform_data omap3logic_gpio_data = {
+	.gpio_base	= OMAP_MAX_GPIO_LINES,
+	.irq_base	= TWL4030_GPIO_IRQ_BASE,
+	.irq_end	= TWL4030_GPIO_IRQ_END,
+	.use_leds	= true,
+	.pullups	= BIT(1),
+	.pulldowns	= BIT(2)  | BIT(6)  | BIT(7)  | BIT(8)
+			| BIT(13) | BIT(15) | BIT(16) | BIT(17),
+};
+
 /* VMMC1 for MMC1 pins CMD, CLK, DAT0..DAT3 (20 mA, plus card == max 220 mA) */
 static struct regulator_init_data omap3logic_vmmc1 = {
 	.constraints = {
@@ -74,16 +209,6 @@ static struct regulator_init_data omap3logic_vmmc1 = {
 	.consumer_supplies      = omap3logic_vmmc1_supply,
 };
 
-static struct twl4030_gpio_platform_data omap3logic_gpio_data = {
-	.gpio_base	= OMAP_MAX_GPIO_LINES,
-	.irq_base	= TWL4030_GPIO_IRQ_BASE,
-	.irq_end	= TWL4030_GPIO_IRQ_END,
-	.use_leds	= true,
-	.pullups	= BIT(1),
-	.pulldowns	= BIT(2)  | BIT(6)  | BIT(7)  | BIT(8)
-			| BIT(13) | BIT(15) | BIT(16) | BIT(17),
-};
-
 static struct twl4030_platform_data omap3logic_twldata = {
 	.irq_base	= TWL4030_IRQ_BASE,
 	.irq_end	= TWL4030_IRQ_END,
@@ -95,109 +220,116 @@ static struct twl4030_platform_data omap3logic_twldata = {
 
 static int __init omap3logic_i2c_init(void)
 {
-	omap3_pmic_init("twl4030", &omap3logic_twldata);
+	u32 pdata_flags = 0;
+	u32 regulators_flags = TWL_COMMON_REGULATOR_VPLL2;
+
+#if defined(CONFIG_USB_MUSB_HDRC) || \
+	defined (CONFIG_USB_MUSB_HDRC_MODULE)
+	pdata_flags |= TWL_COMMON_PDATA_USB;
+#endif
+#if defined(CONFIG_MFD_TWL4030_AUDIO) || \
+	defined (CONFIG_MFD_TWL4030_AUDIO_MODULE)
+	pdata_flags |= TWL_COMMON_PDATA_AUDIO;
+#endif
+#if defined(CONFIG_TWL4030_MADC) || \
+	defined (CONFIG_TWL4030_MADC_MODULE)
+	pdata_flags |= TWL_COMMON_PDATA_MADC;
+#endif
+
+#if defined(CONFIG_OMAP2_DSS) || defined(CONFIG_OMAP2_DSS_MODULE)
+	regulators_flags |= TWL_COMMON_REGULATOR_VDAC;
+#endif
+
+	omap3_pmic_get_config(&omap3logic_twldata, pdata_flags,
+			      regulators_flags);
+
+	omap3logic_twldata.vpll2->constraints.name = "VDVI";
+
+	omap3_pmic_init("tps65950", &omap3logic_twldata);
+	/* i2c2 pins are used for gpio */
+	omap_register_i2c_bus(3, 400, NULL, 0);
 	return 0;
 }
 
-static struct omap2_hsmmc_info __initdata board_mmc_info[] = {
-	{
-		.name		= "external",
-		.mmc		= 1,
-		.caps		= MMC_CAP_4_BIT_DATA,
-		.gpio_cd	= -EINVAL,
-		.gpio_wp	= -EINVAL,
-	},
-	{}      /* Terminator */
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
 };
+#endif
 
-static void __init board_mmc_init(void)
+static void __init omap3logic_opp_init(void)
 {
-	if (machine_is_omap3530_lv_som()) {
-		/* OMAP3530 LV SOM board */
-		board_mmc_info[0].gpio_cd = OMAP3530_LV_SOM_MMC_GPIO_CD;
-		board_mmc_info[0].gpio_wp = OMAP3530_LV_SOM_MMC_GPIO_WP;
-		omap_mux_init_signal("gpio_110", OMAP_PIN_OUTPUT);
-		omap_mux_init_signal("gpio_126", OMAP_PIN_OUTPUT);
-	} else if (machine_is_omap3_torpedo()) {
-		/* OMAP3 Torpedo board */
-		board_mmc_info[0].gpio_cd = OMAP3_TORPEDO_MMC_GPIO_CD;
-		omap_mux_init_signal("gpio_127", OMAP_PIN_OUTPUT);
-	} else {
-		/* unsupported board */
-		printk(KERN_ERR "%s(): unknown machine type\n", __func__);
+	int r = 0;
+
+	/* Initialize the omap3 opp table */
+	if (omap3_opp_init()) {
+		pr_err("%s: opp default init failed\n", __func__);
 		return;
 	}
 
-	omap2_hsmmc_init(board_mmc_info);
-}
-
-static struct omap_smsc911x_platform_data __initdata board_smsc911x_data = {
-	.cs             = OMAP3LOGIC_SMSC911X_CS,
-	.gpio_irq       = -EINVAL,
-	.gpio_reset     = -EINVAL,
-};
+	/* Custom OPP enabled for 36/3730 */
+	if (cpu_is_omap3630()) {
+		struct device *mpu_dev, *iva_dev;
 
-/* TODO/FIXME (comment by Peter Barada, LogicPD):
- * Fix the PBIAS voltage for Torpedo MMC1 pins that
- * are used for other needs (IRQs, etc).            */
-static void omap3torpedo_fix_pbias_voltage(void)
-{
-	u16 control_pbias_offset = OMAP343X_CONTROL_PBIAS_LITE;
-	u32 reg;
+		mpu_dev = omap_device_get_by_hwmod_name("mpu");
 
-	if (machine_is_omap3_torpedo())
-	{
-		/* Set the bias for the pin */
-		reg = omap_ctrl_readl(control_pbias_offset);
+		if (omap3_has_iva())
+			iva_dev = omap_device_get_by_hwmod_name("iva");
 
-		reg &= ~OMAP343X_PBIASLITEPWRDNZ1;
-		omap_ctrl_writel(reg, control_pbias_offset);
+		if (!mpu_dev) {
+			pr_err("%s: Aiee.. no mpu device? %p\n",
+				__func__, mpu_dev);
+			return;
+		}
+		/* Enable MPU 1GHz and lower opps */
+		r = opp_enable(mpu_dev, 800000000);
+		r |= opp_enable(mpu_dev, 1000000000);
 
-		/* 100ms delay required for PBIAS configuration */
-		msleep(100);
+		if (omap3_has_iva()) {
+			/* Enable IVA 800MHz and lower opps */
+			r |= opp_enable(iva_dev, 660000000);
+			r |= opp_enable(iva_dev, 800000000);
+		}
 
-		reg |= OMAP343X_PBIASLITEVMODE1;
-		reg |= OMAP343X_PBIASLITEPWRDNZ1;
-		omap_ctrl_writel(reg | 0x300, control_pbias_offset);
+		if (r) {
+			pr_err("%s: failed to enable higher opp %d\n",
+				__func__, r);
+			opp_disable(mpu_dev, 800000000);
+			opp_disable(mpu_dev, 1000000000);
+			if (omap3_has_iva()) {
+				opp_disable(iva_dev, 660000000);
+				opp_disable(iva_dev, 800000000);
+			}
+		}
 	}
+	return;
 }
 
-static inline void __init board_smsc911x_init(void)
+#if defined(CONFIG_USB_MUSB_HDRC) || \
+	defined (CONFIG_USB_MUSB_HDRC_MODULE)
+static inline void __init omap3logic_init_musb(void)
 {
-	if (machine_is_omap3530_lv_som()) {
-		/* OMAP3530 LV SOM board */
-		board_smsc911x_data.gpio_irq =
-					OMAP3530_LV_SOM_SMSC911X_GPIO_IRQ;
-		omap_mux_init_signal("gpio_152", OMAP_PIN_INPUT);
-	} else if (machine_is_omap3_torpedo()) {
-		/* OMAP3 Torpedo board */
-		board_smsc911x_data.gpio_irq = OMAP3_TORPEDO_SMSC911X_GPIO_IRQ;
-		omap_mux_init_signal("gpio_129", OMAP_PIN_INPUT);
-	} else {
-		/* unsupported board */
-		printk(KERN_ERR "%s(): unknown machine type\n", __func__);
-		return;
-	}
-
-	gpmc_smsc911x_init(&board_smsc911x_data);
+	usb_musb_init(NULL);
 }
-
-#ifdef CONFIG_OMAP_MUX
-static struct omap_board_mux board_mux[] __initdata = {
-	{ .reg_offset = OMAP_MUX_TERMINATOR },
-};
+#else
+static inline void __init omap3logic_init_musb(void) { return; }
 #endif
 
 static void __init omap3logic_init(void)
 {
-	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
-	omap3torpedo_fix_pbias_voltage();
+	int ret;
+	
+	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);	
 	omap3logic_i2c_init();
 	omap_serial_init();
 	omap_sdrc_init(NULL, NULL);
+	omap_nand_flash_init(0, omap_nand_partitions,
+			     ARRAY_SIZE(omap_nand_partitions));
 	board_mmc_init();
-	board_smsc911x_init();
-
+	omap3logic_init_musb();	
+	omap3logic_init_smsc911x();
+	omap3logic_opp_init();
+	
 	/* Ensure SDRC pins are mux'd for self-refresh */
 	omap_mux_init_signal("sdrc_cke0", OMAP_PIN_OUTPUT);
 	omap_mux_init_signal("sdrc_cke1", OMAP_PIN_OUTPUT);
@@ -205,6 +337,7 @@ static void __init omap3logic_init(void)
 
 MACHINE_START(OMAP3_TORPEDO, "Logic OMAP3 Torpedo board")
 	.atag_offset	= 0x100,
+	.reserve	= omap_reserve,
 	.map_io		= omap3_map_io,
 	.init_early	= omap35xx_init_early,
 	.init_irq	= omap3_init_irq,
@@ -214,6 +347,27 @@ MACHINE_END
 
 MACHINE_START(OMAP3530_LV_SOM, "OMAP Logic 3530 LV SOM board")
 	.atag_offset	= 0x100,
+	.reserve	= omap_reserve,
+	.map_io		= omap3_map_io,
+	.init_early	= omap35xx_init_early,
+	.init_irq	= omap3_init_irq,
+	.init_machine	= omap3logic_init,
+	.timer		= &omap3_timer,
+MACHINE_END
+
+MACHINE_START(DM3730_SOM_LV, "Logic DM37x SOM LV board")
+	.atag_offset	= 0x100,
+	.reserve	= omap_reserve,
+	.map_io		= omap3_map_io,
+	.init_early	= omap35xx_init_early,
+	.init_irq	= omap3_init_irq,
+	.init_machine	= omap3logic_init,
+	.timer		= &omap3_timer,
+MACHINE_END
+
+MACHINE_START(DM3730_TORPEDO, "Logic DM37x Torpedo board")
+	.atag_offset	= 0x100,
+	.reserve	= omap_reserve,
 	.map_io		= omap3_map_io,
 	.init_early	= omap35xx_init_early,
 	.init_irq	= omap3_init_irq,
